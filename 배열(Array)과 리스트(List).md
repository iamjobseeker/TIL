# 배열(Array)
+ 데이터가 많아지고 그룹 관리의 필요성에 따라 배열을 사용한다
+ **고정된 크기를 갖는 같은 자료형의 원소들이 연속적인 형태로 구성된 자료구조 (논리적 저장 순서와 물리적 저장 순서가 일치)**
  + 인덱스에 따라 값을 유지하므로 원소가 삭제되어도 빈자리가 남게되어 메모리가 낭비된다
  + 처음 크키를 10으로 지정한다면 5개의 데이터만 저장하더라도 실제 배열의 크기는 10이다
+ 인덱스(indx) : 각 원소의 번호로 0번부터 시작하며, 해당 원소에 접근한다.
+ 데이터 갯수가 확실하게 정해져 있고, 접근이 빈번한 경우 배열이 효율적이다.
+ cache hit 가능성이 커져 성능에 큰 도움이 된다
  + cache hit : CPU가 참조하고자 하는 메모리가 캐시에 존재하는 것
+ 고정이고 연속적인 만큼 인덱스로 random access가 가능하다
  + 접근, 수정 O(1)으로 빠르게 조회가 가능하다
+ 하지만 삽입과 삭제의 경우 연속적인 형태 유지를 위해 shift 연산을 해야하므로 O(n)이 된다


# 리스트(List)
+ 배열의 문제점을 해결하기 위한 자료구조
+ 리스트의 핵심은 원소들 간의 순서로 **순서가 있는 데이터의 모임**이 리스트이며 리스트를 다른 이름으로 시퀀스(sequence)라고도 부른다
+ 배열에서 인덱스는 유일무이한 식별자이지만 리스트에서는 몇 번째 데이터인지 정도의 의미를 가진다.
+ 빈 엘리먼트는 허용하지 않는다
+ 순차성을 보장하지 못하기 때문에 cash hit이 어렵다

출처 : https://jy-tblog.tistory.com/38

*** 
# LinkedList의 개념 알아보기 (List 더 알아보기)
## 메모리
+ 컴퓨터에는 **CPU, 메모리(memory), 스토리지(storage)** 라는 3가지 중요한 부품이 있다
+ 메모리에는 RAM, 스토리지에는 HDD, SSD가 있음
+ 메모리는 속도가 매우 빠른 대신 용량이 작고 전기를 끄면 데이터가 사라지는 휘발성임
+ 반면 스토리지는 속도가 느리지만 용량이 크고 전기를 꺼도 데이터가 사라지지 않는 비휘발성임
+ 따라서 데이터는 기본적으로 스토리지에 저장된다
+ 하지만 **스토리지는 매우 느리기 때문에 CPU와 함께 일을 하기에는 속도면에서 부족**함
+ 그래서 **어떤 프로그램을 실행하면 그 프로그램과 데이터는 메모리로 옮겨지고 CPU는 메모리에 로드된 데이터를 이용해서 여러가지 일을 하게 됨**
+ 그러므로 **실행속도를 결정하는 것은 대체로 메모리이며** 우리가 DS를 배우는 이유는  **메모리의 효율적인 사용**을 위해서임


